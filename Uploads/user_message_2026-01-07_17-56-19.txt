Você é um time sênior de engenharia (Full-Stack + Data + DevOps + Produto). Construa um repositório completo de um web app para analisar preços de cartas Pokémon TCG e identificar oportunidades de lucro (arbitragem e tendências). O projeto precisa estar pronto para rodar localmente via Docker Compose e pronto para deploy público com backend em FastAPI.

0) Objetivo do produto
Criar uma plataforma que:

Ingere continuamente dados de cartas e preços (com atualização incremental).
Armazena snapshots históricos de preços para permitir séries temporais.
Calcula oportunidades (lucro líquido, ROI, spread, momentum) e as rankea com um “Opportunity Score”.
Entrega um Dashboard, um Explorer/Screener, uma Card Detail Page, e uma Settings Page (MVP obrigatório).
Inclui um chatbox que responde perguntas analíticas usando o dataset local e, quando solicitado, faz pesquisa na web com citações (links).
1) Fontes de dados (obrigatórias)
pokemontcg.io API v2: cartas, sets e preços embutidos (TCGplayer e Cardmarket).
PokemonTCG/pokemon-tcg-data (GitHub): dados brutos/JSON (cartas/sets) para seed e fallback.
Requisitos de ingestão:

Respeitar rate limits.
Guardar updatedAt de preços quando disponível.
Reprocessar incrementalmente (somente o que mudou) e criar snapshots diários (ou por janela).
2) Métricas principais e definições (MVP)
2.1 Arbitragem (USD ↔ EUR)
Calcular oportunidade de arbitragem entre mercados:

Preços base (exemplos, ajustar por variante):
TCGplayer (USD): low, market, etc.
Cardmarket (EUR): trendPrice, averageSellPrice, etc.
Conversão FX: EURUSD ou USDEUR (definido via Settings).
Custos/fees (definidos via Settings):
Fee marketplace, fee pagamento, shipping médio, impostos (opcional), slippage.
Métricas:
gross_spread = (sell_price_net - buy_price_net)
roi = gross_spread / buy_price_net
spread_pct = gross_spread / buy_price_net
net_profit = gross_spread (em moeda base)
Validar oportunidade com thresholds mínimos (ex.: ROI mínimo, lucro mínimo).
2.2 Tendência e momentum
Aproveitar variações disponíveis (ex.: Cardmarket avg1, avg7, avg30 e/ou snapshots calculados):

delta_1d, delta_7d, delta_30d (percentual e absoluto)
momentum_score: combinação ponderada (ex.: 1d + 7d + 30d)
acceleration_score: diferença entre deltas (ex.: delta_7d - delta_30d/4), ou mudança de inclinação.
2.3 “Opportunity Score” (ranking)
Criar um score único com pesos configuráveis em Settings. Exemplo (ajuste fino no código):

Componentes:
roi_component
spread_component
momentum_component
Penalidades de risco (ex.: volatilidade, baixa liquidez estimada, baixa confiança, poucos pontos históricos)
Normalizar componentes (min-max robusto ou z-score robusto) antes da combinação.
Resultado: Opportunity Score em escala 0–100.
3) Liquidez e “velocidade de venda” sem volume direto (MVP pragmático)
Como a API pode não fornecer volume/listings:

Definir proxies:
Proxy de liquidez por estabilidade de preço: menor ruído + consistência de avgSellPrice/trendPrice ao longo do tempo sugere mercado mais líquido.
Proxy por dispersão: diferença grande entre lowPrice e trendPrice pode indicar baixa liquidez/ineficiência.
Proxy por disponibilidade de múltiplas variantes e presença contínua de preço (menos “gaps” no histórico).
Derivar liquidity_score (0–1) e sale_velocity_score (0–1) como heurísticas explicáveis ao usuário.
Exibir claramente “estimado (proxy)” na UI.
4) Arquitetura (stack recomendada e obrigatória no backend)
4.1 Frontend
Next.js + TypeScript
TailwindCSS
UI: tabelas/grades, filtros avançados, gráficos de histórico e ranking.
Comunicação:
REST para consultas
SSE (Server-Sent Events) ou WebSocket para atualizações (opcional no MVP, recomendado).
4.2 Backend (obrigatório)
FastAPI (Python) como API principal.
Servidor ASGI:
Dev: uvicorn
Prod: uvicorn --workers N (ou alternativa equivalente) em container conforme deploy oficial (FastAPI — Deployment with Docker).
Banco: PostgreSQL
Migrações: Alembic
Cache opcional: Redis (Phase 2)
Jobs/ingestão contínua:
MVP: processo separado “ingestor” (container/serviço) rodando loop e gravando no Postgres.
Phase 2: fila (Celery/RQ) + scheduler.
4.3 Realtime
MVP: endpoints + refresh manual/intervalo no frontend.
Recomendado: SSE para “status do ingest” e “novas oportunidades”.
5) Modelo de dados (PostgreSQL) — mínimo necessário
Tabelas (mínimo):

cards (id, name, set_id, number, rarity, images, etc.)
sets (id, name, release_date, etc.)
price_sources (tcgplayer/cardmarket, currency)
price_snapshots
id, card_id, variant, source, currency, timestamp, price_low, price_market/trend, avg1, avg7, avg30, raw_json
opportunities (materialized ou view + cache)
card_id, variant, calc_timestamp, roi, net_profit, spread_pct, momentum, opportunity_score, risk_flags, etc.
settings (single row ou por user futuramente)
FX, fees, thresholds, pesos do score.
Índices:

price_snapshots(card_id, variant, source, timestamp desc)
opportunities(opportunity_score desc)
6) Backend API (FastAPI) — endpoints mínimos
GET /health (para deploy e monitoramento)
GET /cards (lista paginada + filtros)
GET /cards/{id} (detalhe + últimos snapshots + métricas)
GET /opportunities (screener: filtros + sort)
GET /timeseries?card_id=...&variant=...&source=...&range=...
POST /settings e GET /settings
POST /admin/ingest/run (manual trigger, protegido por token simples no MVP)
(Opcional) GET /events (SSE) para progresso e status do ingest
7) UI/UX — MVP obrigatório
7.1 Dashboard
Top oportunidades por score
Gráfico de distribuição de ROI/score
“Recent movers” (momentum)
Status do ingest (última atualização, lag)
7.2 Explorer / Screener
Filtros avançados:

Set, raridade, variante (normal/holo/reverse/etc.), faixa de preço
ROI mínimo, lucro mínimo, spread mínimo
Momentum mínimo
Penalidades/risco (checkbox: “excluir baixa confiança”)
Ordenação por score/ROI/lucro/momentum
7.3 Card Detail Page
Identificação, imagens
Série temporal (snapshots)
Breakdown de arbitragem (com fees e FX)
Breakdown do score (explicabilidade: componentes e penalidades)
Alertas (placeholder no MVP, funcional no Phase 2)
7.4 Settings Page
FX (manual + opção “atualizar via serviço externo” como Phase 2)
Fees (por marketplace)
Pesos do Opportunity Score
Thresholds
Preferência de moeda base (USD/EUR)
8) Chatbox (MVP: coerente e “tool-like”)
O chatbox deve:

Responder perguntas analíticas somente com dados locais quando o usuário pedir “do dataset”.
Fazer pesquisa web apenas quando o usuário pedir explicitamente (ex.: “pesquise na web”) e retornar links citados.
Tipos de perguntas:
“Top 10 cartas com maior ROI hoje”
“Compare card A vs card B nos últimos 30 dias”
“Quais cartas do set X aceleraram na última semana?”
A resposta deve incluir:
resumo
tabelas pequenas (top N)
explicação do critério usado
limitações (ex.: liquidez é proxy)
9) Ingestão contínua (detalhes de implementação)
Serviço ingestor:
busca mudanças por set e/ou queries
grava price_snapshots
recalcula oportunidades incrementalmente (ou agenda job)
Estratégia:
Backfill inicial via GitHub JSON + API
Depois incremental via API e updatedAt
Observabilidade mínima:
logs estruturados
tabela ingest_runs (início/fim, itens processados, erros)
10) Phase 2 (incluir no roadmap, mas não bloquear MVP)
Alerts: alertas por thresholds (score/ROI/momentum), email/webhook.
Modelo preditivo: forecasting simples por carta/variante com validação; feature flags.
Detecção de outliers: robust z-score/MAD e/ou Hampel para spikes.
Sold Comps avançado:
módulo separado para “comps” (ex.: eBay sold/completed), deixando claro limitações de acesso e compliance.
armazenar comps e reconciliar com preços agregados.
11) Entregáveis (obrigatórios)
Repositório monorepo:
frontend/ (Next.js)
backend/ (FastAPI)
docker-compose.yml (dev)
README.md completo (setup, comandos, variáveis, troubleshooting)
Seeds: script para popular sets/cards inicialmente.
Testes básicos:
backend: unit tests para cálculo de ROI/score
e2e mínimo opcional (Phase 2)
12) Deploy público (guia obrigatório no README)
Você deve implementar e documentar duas estratégias:

Estratégia A (recomendada): Frontend na Vercel + Backend FastAPI em container + Postgres gerenciado
Frontend:
Deploy do Next.js na Vercel.
Configurar NEXT_PUBLIC_API_BASE_URL apontando para o backend.
Regras de env vars:
Variáveis públicas no client precisam prefixo NEXT_PUBLIC_ (Next.js — Environment Variables).
Configuração de env vars no painel da Vercel (Vercel — Environment Variables).
Backend:
Publicar container do FastAPI.
Comando de execução em produção deve ser ASGI (Uvicorn) com porta e workers configuráveis via env, conforme boas práticas do deploy em Docker (FastAPI — Deployment with Docker).
Expor GET /health para health checks.
Banco:
Usar Postgres gerenciado e DATABASE_URL via env.
CORS:
Permitir origem do domínio do frontend.
Estratégia B: VM única com Docker Compose (self-host)
Subir docker compose up -d com:
frontend (Next.js)
backend (FastAPI)
db (Postgres)
Reverse proxy na frente (Nginx/Caddy) para TLS e roteamento:
/api → backend
/ → frontend
Backup do Postgres e política de retenção de snapshots.
13) Critérios de aceitação (MVP)
Rodar localmente com um comando (docker compose up --build) e abrir a UI.
Dashboard mostra oportunidades calculadas.
Explorer filtra e ordena corretamente.
Card detail mostra histórico e breakdown do score.
Settings altera pesos/fees e reflete no ranking.
Ingestor roda e atualiza snapshots.
Backend tem /health funcional.
Chatbox responde pelo dataset (com queries reais) e, quando acionado para web, retorna links citados.